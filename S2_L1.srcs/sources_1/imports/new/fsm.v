`timescale 1ns / 1ps

module fsm (input clk,
            input RST,                //сигнал с кномпки о перезапуске
            input [3:0] SW,           //движковые переключатели
            input set,                //сигнал с кнопки сет
            input sort,               //сигнал с кнопки для сортировки
            output reg [31:0] memory, //память с семисигментников
            output reg [7:0] mask     //маска для отображения не всех семисигментников
            );
            
    //для работы с памятью
    reg [31:0] memory_sorted; //память для сортировки на ней
    reg [3:0] state;          //состояния
    reg [3:0] count;          //подсчет кол-ва введенных цифр
    
    //для сортировки
    reg [4:0] k;      //коэффициент для сравнения элементов 
    reg [3:0] temp;   //переменная для замены элементов местами
    reg [4:0] i ;     //счетчик перехода по массиву
    
    //для проверки работы 
    reg [3:0] eli;
    reg [3:0] elik ;

    initial begin
        memory = 32'b0;     //зануляем память
        mask = 8'b1;        //маска равна 1 - только крайнее правое число
        state = 4'd0;       //изначально состояние 0
        count =4'd0;        //изначально у нас введено 0 чисел
        
        k=0;                //зануляем коэффициент разницы между сравниваемыми элементами
        i=0;                //зануляем счетчик перехода по массиву
        memory_sorted=0;    //зануляем память на которой будем сортировать
        temp = 4'd0;        //зануляем переменную для замены элементов местами
        
        eli = 4'd0;
        elik = 4'd0;
    end
    
    always@(posedge clk) begin
        if (RST) begin
                memory_sorted =0;    //зануляем память на которой будем сортировать
                memory = 32'b0;      //зануляем память
                mask = 8'b1;         //маска равнв 1 только крайнее правре число
                state = 4'd0;        //изначально состояние 0
                count =4'd0;         //изначально у нас введено 0 чисел
           end
           
       case(state)
           4'd0: begin
            memory_sorted <=0;       //зануляем память на которой будем сортировать
            memory <= 32'b0;         //зануляем память  семисигментников                                   
            mask <= 8'b1;            //маска равнв 1 только крайнее правре число                                              
            state <= 1'b1;           //переходим в 1 состояние                                                               
            count =4'd0;             //изначально у нас введено 0 чисел                    
           end
           
           4'd1: begin
               memory <= {memory[31:4],SW[3:0]};// в последни 4 бита памяти вводим со свитчеров
               if (sort) begin // если нажали кнопку сортировки
                   state = 4'd3; // переходим в 3 состояние
               end               
               else if (set) begin            //если нажали кнопку сет
                   memory <= memory << 4;     //сдвигаем память на 4 бита влево для записи новой цифры
                   if (count < 3'b111) begin  //если введено меньше 8 цифр
                       count <= count + 4'd1; //увеличиваем кол-во введенных цифр
                       mask <= (mask << 1) + 1'b1; //сдвигаем маску чтобы было видно новое число
                   end
               end
           end
           
           /*4'd2: begin //ненужное состояние, потом уберу
                state <= 4'd3;
           end*/
           4'd2: begin                    //конечное состояние уже после сортировки 
                memory <= memory_sorted;  //в память семисигментников записываем отсортированный массив
                if (set) state = 4'd0;    //если нажмем сет, то снова можно будет ввести массив
           end
           4'd3: begin                    //начало сортировки
                memory_sorted <= memory;  //записываем в спец память память с семисигментников
                i = 5'd0;                 //просто зануляем счетчик перехода по массиву
                temp = 4'd0;              //просто зануляем переменную жля переставления элементов
                k = count+1;              //изначально k равен длинне массива 
                state = 4'd4;             //переходим к сортировке
           end
           4'd4: begin
                if( k > 5'd1) begin        //если k > 1 (условие сортировки)
                    k <= (k * 1000 / 1247);//высчитывае новый коэффициент разница между элементами
                    i <= 4'd1;     //зануляем счетчик перехода по массиву //новое
                    state <= 4'd5;        //переходим в состояния для цикла for в виде автоматаn //5 or 6
                end 
                else begin
                    memory <= memory_sorted; //сортировка выполнена загружаем рез-т в память
                    state <= 4'd2;           //переход в 2 состояние для ожидания
                end 
           end
           /*4'd6: begin
                //i <= 4'd0;     //зануляем счетчик перехода по массиву 
                state <= 4'd7; //переходим к условию необходимо ли еще проходиться по массиву в этой итерации
           end*/
           4'd5: begin //проверяем необходимо ли еще проходиться по массиву в этой итерации
                if ((k+i) < (count +2)) begin  //проверяем условие закончился ли массив
                    state = 4'd6;              //переходим к сравнению элементов
                    
                end
                else begin
                    state <= 4'd4;             //переходим для пересчета k для новой итерации
                end 
           end
           /*4'd7:begin //ненужное состояние, потом уберу
           //if (memory_sorted[i*4-1-:4] < memory_sorted[(k+i)*4-1-:4]) state = 4'd9;
           //else state = 4'd10;
           end*/
           4'd6: begin //если i-тый элемент меньше i+k элемента, то меняем местами
                eli <= memory_sorted[i*4-1-:4];
                elik <= memory_sorted[(k+i)*4-1-:4];
                if (memory_sorted[i*4-1-:4] < memory_sorted[(k+i)*4-1-:4]) 
                //if (eli < elik)
                begin 
                    //temp <= memory_sorted[i*4-1-:4];
                    state = 4'd7;
                    //memory_sorted[i*4-1-:4] <= memory_sorted[(k+i)*4-1-:4];
                    //memory_sorted[(k+i)*4-1-:4] <= temp;
                end
                else state = 4'd10;
           end
           4'd7:begin //ненужное состояние, потом уберу
           temp <= memory_sorted[i*4-1-:4];
           state = 4'd8;
           end
           4'd8:begin //ненужное состояние, потом уберу
           memory_sorted[i*4-1-:4] <= memory_sorted[(k+i)*4-1-:4];
           state = 4'd9;
           end
           4'd9:begin //ненужное состояние, потом уберу
           memory_sorted[(k+i)*4-1-:4] <= temp;
           state = 4'd10;
           end
           4'd10: begin
                i <= i+ 4'd1;  //увеличиваем счетчик перехода по массиву
                state <= 4'd5; //переходим к проверке условия, отсортирован ли массив
           end
       endcase
   end
       
endmodule
       
